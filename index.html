<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cellular Automaton Universality</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            flex: 1;
            height: 100%;
        }
        #llmButton {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
<script>
// Parameters
const RULE = 110;
const ROW_SIZE = 100;
const CELL_SIZE = 8;
const CANVAS_WIDTH = ROW_SIZE * CELL_SIZE;
const CANVAS_HEIGHT = window.innerHeight;
const STEPS = 50;

// Base class for shared logic
class CellularAutomaton {
    constructor(size, rule) {
        this.cells = new Array(size).fill(0);
        this.ruleSet = this.getRuleSet(rule);
    }

    getRuleSet(rule) {
        return Array.from(rule.toString(2).padStart(8, '0')).map(Number);
    }

    setCellState(index, state) {
        if (index >= 0 && index < this.cells.length) {
            this.cells[index] = state;
        } else {
            throw new Error('Index out of bounds');
        }
    }

    async computeCellState(left, center, right) {
        throw new Error('computeCellState must be implemented by subclass');
    }

    async nextGeneration() {
        const len = this.cells.length;
        let newCells = new Array(len);
        for (let i = 0; i < len; i++) {
            const left = this.cells[(i - 1 + len) % len];
            const center = this.cells[i];
            const right = this.cells[(i + 1) % len];
            newCells[i] = await this.computeCellState(left, center, right);
        }
        this.cells = newCells;
        return newCells;
    }
}

class DeterministicCellularAutomaton extends CellularAutomaton {
    computeCellState(left, center, right) {
        const index = 4 * left + 2 * center + right;
        return this.ruleSet[7 - index];
    }
}

class LLMCellularAutomaton extends CellularAutomaton {
    getCASystemPrompts() {
        return [
            { role: "system", content: "You are a dictionary lookup engine" },
            { role: "system", content: "Below are your dictionary entries" },
            { role: "system", content: `(1,1,1) -> ${this.ruleSet[0]}` },
            { role: "system", content: `(1,1,0) -> ${this.ruleSet[1]}` },
            { role: "system", content: `(1,0,1) -> ${this.ruleSet[2]}` },
            { role: "system", content: `(1,0,0) -> ${this.ruleSet[3]}` },
            { role: "system", content: `(0,1,1) -> ${this.ruleSet[4]}` },
            { role: "system", content: `(0,1,0) -> ${this.ruleSet[5]}` },
            { role: "system", content: `(0,0,1) -> ${this.ruleSet[6]}` },
            { role: "system", content: `(0,0,0) -> ${this.ruleSet[7]}` },
            { role: "system", content: "When you receive a key from the user, you respond only with the corresponding value." },
        ];
    }

    async computeCellState(left, center, right) {
        const messages = [
            ...this.getCASystemPrompts(),
            { role: 'user', content: `(${left},${center},${right})` }
        ];
        return this.getLLMResponse(messages, {
            model: 'llama3.1:latest',
            messages,
            stream: false,
            format: { type: 'number', enum: [0, 1] },
            options: { temperature: 0 }
        });
    }

    async getLLMResponse(messages, body = {}) {
        const response = await fetch("http://localhost:11434/api/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        if (data && data.message) {
            try {
                const parsed = JSON.parse(data.message.content);
                return parsed;
            } catch (e) {
                console.error("Failed to parse LLM structured response:", data.message);
                return null;
            }
        }
        return null;
    }
}

// Automaton setup
function setupAutomaton(AutomatonClass) {
    const automaton = new AutomatonClass(ROW_SIZE, RULE);
    automaton.setCellState(Math.floor(automaton.cells.length / 2), 1);
    return [automaton, [automaton.cells.slice()]];
}

function drawGeneration(cells, ctx, y, cellSize, getCellColor) {
    for (let i = 0; i < cells.length; i++) {
        ctx.fillStyle = getCellColor(cells[i], i);
        ctx.fillRect(i * cellSize, y, cellSize, cellSize);
    }
}

async function advanceAutomaton(automaton, history) {
    await automaton.nextGeneration();
    history.push(automaton.cells.slice());
}

async function runCA(steps, ctx, history, automaton, getCellColor) {
    for (let step = 0; step < steps; step++) {
        drawGeneration(history[step], ctx, step * CELL_SIZE, CELL_SIZE, getCellColor);
        await advanceAutomaton(automaton, history);
    }
}

function createContainer() {
    const container = document.createElement('div');
    container.id = 'container';
    document.body.appendChild(container);
    return container;
}

function createButton(container) {
    const button = document.createElement('button');
    button.id = 'llmButton';
    button.textContent = 'Run LLM CA';
    container.appendChild(button);
    return button;
}

// DOM setup
function createCanvas(container, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    canvas.style.flex = '1';
    canvas.style.height = '100%';
    container.appendChild(canvas);
    return canvas.getContext('2d');
}

const container = createContainer();
const llmButton = createButton(container);
const ctx = createCanvas(container, CANVAS_WIDTH, CANVAS_HEIGHT);

const [deterministicCA, deterministicHistory] = setupAutomaton(DeterministicCellularAutomaton);
const [llmCA, llmHistory] = setupAutomaton(LLMCellularAutomaton);

// First run the deterministic CA and render it as reference.
const deterministicColor = cell => cell ? 'lightgray' : 'white';
runCA(STEPS, ctx, deterministicHistory, deterministicCA, deterministicColor);

llmButton.onclick = async () => {
    llmButton.disabled = true;
    // Now run the LLM-based CA and render it on top of the reference.
    const llmColor = (cell, i) => cell ? 'black' : 'white';
    await runCA(STEPS, ctx, llmHistory, llmCA, llmColor);
    llmButton.textContent = 'LLM CA Complete';
};
</script>
</body>
</html>
