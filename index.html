<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cellular Automaton Universality</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            flex: 1;
            height: 100%;
        }
        #llmButton {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
<div id="container"></div>
<button id="llmButton">Run LLM CA</button>
<script>

// Base class for shared logic
class CellularAutomaton {
    constructor(size, rule) {
        this.cells = new Array(size).fill(0);
        this.ruleSet = this.getRuleSet(rule);
    }
    getRuleSet(rule) {
        return Array.from(rule.toString(2).padStart(8, '0')).map(Number);
    }
    setCellState(index, state) {
        if (index >= 0 && index < this.cells.length) {
            this.cells[index] = state;
        } else {
            throw new Error('Index out of bounds');
        }
    }
}

class DeterministicCellularAutomaton extends CellularAutomaton {
    computeCellState(left, center, right) {
        const index = 4 * left + 2 * center + right;
        return this.ruleSet[7 - index];
    }
    nextGeneration() {
        const len = this.cells.length;
        let newCells = new Array(len);
        for (let i = 0; i < len; i++) {
            const left = this.cells[(i - 1 + len) % len];
            const center = this.cells[i];
            const right = this.cells[(i + 1) % len];
            newCells[i] = this.computeCellState(left, center, right);
        }
        this.cells = newCells;
    }
}

class LLMCellularAutomaton extends CellularAutomaton {
    async getLLMResponse(messages, body = {}) {
        const response = await fetch("http://localhost:11434/api/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        if (data && data.message) {
            try {
                const parsed = JSON.parse(data.message.content);
                return parsed;
            } catch (e) {
                console.error("Failed to parse LLM structured response:", data.message);
                return null;
            }
        }
        return null;
    }

    getCASystemPrompts() {
        return [
            { role: "system", content: "You are a dictionary lookup engine" },
            { role: "system", content: "Below are your dictionary entries" },
            { role: "system", content: `[1,1,1] -> ${this.ruleSet[0]}` },
            { role: "system", content: `[1,1,0] -> ${this.ruleSet[1]}` },
            { role: "system", content: `[1,0,1] -> ${this.ruleSet[2]}` },
            { role: "system", content: `[1,0,0] -> ${this.ruleSet[3]}` },
            { role: "system", content: `[0,1,1] -> ${this.ruleSet[4]}` },
            { role: "system", content: `[0,1,0] -> ${this.ruleSet[5]}` },
            { role: "system", content: `[0,0,1] -> ${this.ruleSet[6]}` },
            { role: "system", content: `[0,0,0] -> ${this.ruleSet[7]}` },
            { role: "system", content: "When you receive a key from the user, you respond only with the corresponding value." },
        ];
    }

    async computeCellState(left, center, right) {
        const messages = [
            ...this.getCASystemPrompts(),
            { role: 'user', content: `[${left},${center},${right}]` }
        ];
        return this.getLLMResponse(messages, {
            model: 'llama3.1:latest',
            messages,
            stream: false,
            format: { type: 'number', enum: [0, 1] },
            options: { temperature: 0 }
        });
    }

    async nextGeneration() {
        const len = this.cells.length;
        let newCells = new Array(len);
        for (let i = 0; i < len; i++) {
            const left = this.cells[(i - 1 + len) % len];
            const center = this.cells[i];
            const right = this.cells[(i + 1) % len];
            newCells[i] = await this.computeCellState(left, center, right);
        }
        this.cells = newCells;
        return newCells;
    }
}

// Parameters
const RULE = 110;
const ROW_SIZE = 100;
const CELL_SIZE = 8;
const canvasWidth = ROW_SIZE * CELL_SIZE;
const canvasHeight = window.innerHeight;
const STEPS = 50;

// DOM setup
const container = document.getElementById('container');
function createCanvas(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    canvas.style.flex = '1';
    canvas.style.height = '100%';
    container.appendChild(canvas);
    return canvas.getContext('2d');
}
const ctx = createCanvas(canvasWidth, canvasHeight);

// Automaton setup
let deterministicAutomaton = new DeterministicCellularAutomaton(ROW_SIZE, RULE);
deterministicAutomaton.setCellState(Math.floor(deterministicAutomaton.cells.length / 2), 1);
let deterministicGenerations = [deterministicAutomaton.cells.slice()];

let llmAutomaton = new LLMCellularAutomaton(ROW_SIZE, RULE);
llmAutomaton.setCellState(Math.floor(llmAutomaton.cells.length / 2), 1);
let llmGenerations = [llmAutomaton.cells.slice()];

function drawGeneration(cells, ctx, y, cellSize, getCellColor) {
    for (let i = 0; i < cells.length; i++) {
        ctx.fillStyle = getCellColor(cells[i], i);
        ctx.fillRect(i * cellSize, y, cellSize, cellSize);
    }
}

function advanceDeterministic() {
    deterministicAutomaton.nextGeneration();
    deterministicGenerations.push(deterministicAutomaton.cells.slice());
}

async function advanceLLM(step) {
    await llmAutomaton.nextGeneration();
    llmGenerations.push(llmAutomaton.cells.slice());
}

async function runDeterministicCA(steps) {
    const deterministicColor = cell => cell ? 'lightgray' : 'white';
    for (let step = 0; step < steps; step++) {
        drawGeneration(deterministicGenerations[step], ctx, step * CELL_SIZE, CELL_SIZE, deterministicColor);
        advanceDeterministic();
    }
}

async function runLLMCA(steps) {
    const llmColor = (cell, i) => cell ? 'black' : 'white';
    for (let step = 0; step < steps; step++) {
        drawGeneration(llmGenerations[step], ctx, step * CELL_SIZE, CELL_SIZE, llmColor);
        await advanceLLM(step);
    }
}

// Button logic
const llmButton = document.getElementById('llmButton');
runDeterministicCA(STEPS);
llmButton.onclick = async () => {
    llmButton.disabled = true;
    await runLLMCA(STEPS);
    llmButton.textContent = 'LLM CA Complete';
};
</script>
</body>
</html>
